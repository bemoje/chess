/*!
 * bemoje-chess-engine v0.0.0
 * (c) Benjamin MÃ¸ller Jensen
 * Released under the MIT License.
 */
!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports):"function"==typeof define&&define.amd?define(["exports"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self)["bemoje-chess-engine"]={})}(this,(function(t){"use strict";class e{constructor(t,e,i){this.player=t,this.index=e,this.position=i,this.moves=[],this.player.game.board.setPiece(this)}get game(){return this.player.game}get type(){return this.constructor.name}get hasMoved(){return this.moves.length>0}get color(){return this.player.color}registerMove(t){this.moves.push(t),this.position=t.to.clone()}remove(){this.position=null}isMoveTargetOwnPiece(t){const e=this.game.board.getPieceByPosition(t);return null!==e&&this.player===e.player}isValidMove(t){return this.isMoveTargetOwnPiece(t)}getValidMovePositions(){return[]}isValidMovePosition(t){return!!this.getValidMovePositions().find((e=>e.compare(t)))}}class i extends e{getMovePositionsWithinBounds(){const t=this.position;return t?t.getAllDiagonalRecursive():[]}}function o(t){const e=[],i=t.length;for(let o=0;o<i;o++){const i=t[o];i&&e.push(i)}return e}function s(t,e){const i=function(i,o="arg"){if(!e(i))throw new TypeError(`Expected ${o} to be ${t}. ${o}: ${i}`)};return Object.defineProperty(i,"name",{value:e.name.replace(/^is/,"assert")}),i}const n="A".charCodeAt(0);function r(t){return String.fromCharCode(t+n)}function h(t){return(t+1).toString()}function g(t){return t.toUpperCase().charCodeAt(0)-n}function a(t){return Number(t.charAt(0))-1}function c(t){return r(t[0])+h(t[1])}function u(t){return[g(t.charAt(0)),a(t.charAt(1))]}function l(t){return t>=0&&t<=7}function f(t){return l(t[0])&&l(t[1])}function d(t){return 2===t.length&&f(u(t))}const p=s("a positive integer between 0 and 7",l),v=s("an array containing two positive integers between 0 and 7",f),w=s("a valid A1-notation string",d);class m{constructor(t){this.game=t,this.grid=[];let e=0;for(;e<8;)this.grid.push(new Array(8).fill(null,0,7)),e++}getPieceByXY(t,e){return this.grid[e][t]}getPieceByPosition(t){return this.getPieceByXY(t.x,t.y)}getPieceByA1(t){const[e,i]=u(t);return this.getPieceByXY(e,i)}setPiece(t){const e=t.position;e&&(this.grid[e.y][e.x]=t)}removePiece(t){if(t){const e=t.position;e&&(this.grid[e.y][e.x]=null)}}registerMove(t){const e=t.from,i=t.to,o=this.grid[e.y][e.x];this.grid[i.y][i.x]=o,this.grid[e.y][e.x]=null}}class A{constructor(t,e,i=!1){i||v([t,e],"x and y"),this.x=t,this.y=e}static fromA1Notation(t){const e=u(t);return new A(e[0],e[1])}get A1(){return c([this.x,this.y])}compare(t){return this.x===t.x&&this.y===t.y}clone(){return new A(this.x,this.y,!0)}toArray(){return[this.x,this.y]}getModulation(t,e){try{return new A(this.x+t,this.y+e)}catch(t){return null}}getUp(){return this.getModulation(0,1)}getDown(){return this.getModulation(0,-1)}getLeft(){return this.getModulation(-1,0)}getRight(){return this.getModulation(1,0)}getUpLeft(){return this.getModulation(-1,1)}getUpRight(){return this.getModulation(1,1)}getDownLeft(){return this.getModulation(-1,-1)}getDownRight(){return this.getModulation(1,-1)}getUpUp(){return this.getModulation(0,2)}getDownDown(){return this.getModulation(0,-2)}getUpUpLeft(){return this.getModulation(-1,2)}getUpUpRight(){return this.getModulation(1,2)}getDownDownLeft(){return this.getModulation(-1,-2)}getDownDownRight(){return this.getModulation(1,-2)}getLeftLeftUp(){return this.getModulation(-2,1)}getLeftLeftDown(){return this.getModulation(-2,-1)}getRightRightUp(){return this.getModulation(2,1)}getRightRightDown(){return this.getModulation(2,-1)}getAllStraight(){return o([this.getUp(),this.getDown(),this.getLeft(),this.getRight()])}getAllDiagonal(){return o([this.getUpLeft(),this.getUpRight(),this.getDownLeft(),this.getDownRight()])}getAllStraightAndDiagonal(){return[...this.getAllStraight(),...this.getAllDiagonal()]}getAllKnightMovePositions(){return o([this.getUpUpLeft(),this.getUpUpRight(),this.getDownDownLeft(),this.getDownDownRight(),this.getLeftLeftUp(),this.getLeftLeftDown(),this.getRightRightUp(),this.getRightRightDown()])}getRecursive(t){const e=[];let i;for(i=this;i=t.call(i);)e.push(i);return e}getUpRecursive(){return this.getRecursive(this.getUp)}getDownRecursive(){return this.getRecursive(this.getDown)}getLeftRecursive(){return this.getRecursive(this.getLeft)}getRightRecursive(){return this.getRecursive(this.getRight)}getUpLeftRecursive(){return this.getRecursive(this.getUpLeft)}getUpRightRecursive(){return this.getRecursive(this.getUpRight)}getDownLeftRecursive(){return this.getRecursive(this.getDownLeft)}getDownRightRecursive(){return this.getRecursive(this.getDownRight)}getAllStraightRecursive(){return[this.getUpRecursive(),this.getDownRecursive(),this.getLeftRecursive(),this.getRightRecursive()]}getAllDiagonalRecursive(){return[this.getUpLeftRecursive(),this.getUpRightRecursive(),this.getDownLeftRecursive(),this.getDownRightRecursive()]}getAllStraightAndDiagonalRecursive(){return[...this.getAllStraightRecursive(),...this.getAllDiagonalRecursive()]}}class R extends e{getMovePositionsWithinBounds(){const t=this.position;if(!t)return[];const e=[];if("white"===this.color){const i=t.getUp();i&&e.push(i);const o=t.getUpUp();o&&!this.hasMoved&&e.push(o);const s=t.getUpLeft();if(s){const t=this.game.board.getPieceByPosition(s);if(t){const i=t.position;i&&"black"===t.color&&e.push(i.clone())}}const n=t.getUpRight();if(n){const t=this.game.board.getPieceByPosition(n);if(t){const i=t.position;i&&"black"===t.color&&e.push(i.clone())}}}else{const i=t.getDown();i&&e.push(i);const o=t.getDownDown();o&&!this.hasMoved&&e.push(o);const s=t.getDownLeft();if(s){const t=this.game.board.getPieceByPosition(s);if(t){const i=t.position;i&&"white"===t.color&&e.push(i.clone())}}const n=t.getDownRight();if(n){const t=this.game.board.getPieceByPosition(n);if(t){const i=t.position;i&&"white"===t.color&&e.push(i.clone())}}}return e}}class M extends e{getMovePositionsWithinBounds(){const t=this.position;return t?t.getAllKnightMovePositions():[]}}class P extends e{getMovePositionsWithinBounds(){const t=this.position;return t?t.getAllStraightAndDiagonalRecursive():[]}}class y extends e{getMovePositionsWithinBounds(){const t=this.position;if(!t)return[];const e=[];return e.push(...t.getAllStraightRecursive()),"white"===this.color?e.push(A.fromA1Notation("D1")):e.push(A.fromA1Notation("D7")),e}isValidMove(t){return!this.isMoveTargetOwnPiece(t)||this.isValidCastleMove(t)}isValidCastleMove(t){const e=this.game.board.getPieceByPosition(t);return!!e&&("King"===e.type&&!e.hasMoved&&!this.hasMoved)}}class D extends e{getMovePositionsWithinBounds(){const t=this.position;if(!t)return[];const e=t.getAllStraightAndDiagonal();return"white"===this.color?e.push(A.fromA1Notation("A1"),A.fromA1Notation("H1")):e.push(A.fromA1Notation("A7"),A.fromA1Notation("H7")),e}isValidMove(t){return!this.isMoveTargetOwnPiece(t)||this.isValidCastleMove(t)}isValidCastleMove(t){const e=this.game.board.getPieceByPosition(t);return!!e&&("Rook"===e.type&&!e.hasMoved&&!this.hasMoved)}}class U{constructor(t,e){let o,s;if(this.game=t,this.color=e,"white"===e)o="1",s="2";else{if("black"!==e)throw new Error("Invalid color");o="8",s="7"}this.pieces=[new D(this,0,A.fromA1Notation("E"+o)),new P(this,1,A.fromA1Notation("D"+o)),new i(this,2,A.fromA1Notation("C"+o)),new i(this,3,A.fromA1Notation("F"+o)),new M(this,4,A.fromA1Notation("B"+o)),new M(this,5,A.fromA1Notation("G"+o)),new y(this,6,A.fromA1Notation("A"+o)),new y(this,7,A.fromA1Notation("H"+o)),new R(this,8,A.fromA1Notation("A"+s)),new R(this,9,A.fromA1Notation("B"+s)),new R(this,10,A.fromA1Notation("C"+s)),new R(this,11,A.fromA1Notation("D"+s)),new R(this,12,A.fromA1Notation("E"+s)),new R(this,13,A.fromA1Notation("F"+s)),new R(this,14,A.fromA1Notation("G"+s)),new R(this,15,A.fromA1Notation("H"+s))]}}class b{constructor(t,e,i=null){const o=t.position;if(!o)throw new Error("Cannot move a piece that is not on the board.");this.piece=t,this.takes=i,this.from=o.clone(),this.to=e.clone()}}class L{constructor(){this.board=new m(this),this.white=new U(this,"white"),this.black=new U(this,"black"),this.moves=[]}forEachPiece(t){const e=this.white.pieces,i=this.black.pieces;for(let o=0;o<16;o++)if(!0===t(e[o])||!0===t(i[o]))return}makeMove(t,e,i){if(!i&&!t.isValidMovePosition(e))throw new Error("Invalid move.");{const i=t.game.board.getPieceByPosition(e),o=new b(t,e,i);this.board.registerMove(o),t.registerMove(o),i&&i.remove()}}clone(){const t=new L,e=t.white.pieces,i=t.black.pieces,o=this.moves,s=o.length;for(let n,r=0;r<s;r++)n=o[r].piece,t.makeMove(("white"===n.color?e:i)[n.index],o[r].to.clone(),!0);return t}}t.Bishop=i,t.Board=m,t.Game=L,t.King=D,t.Knight=M,t.Move=b,t.Pawn=R,t.Player=U,t.Position=A,t.Queen=P,t.Rook=y,t.assertValidA1=w,t.assertValidXY=v,t.assertValidXYPoint=p,t.from_1_to_Y=a,t.from_A1_to_XY=u,t.from_A_to_X=g,t.from_XY_to_A1=c,t.from_X_to_A=r,t.from_Y_to_1=h,t.isValidA1=d,t.isValidXY=f,t.isValidXYPoint=l,Object.defineProperty(t,"__esModule",{value:!0})}));
//# sourceMappingURL=index.umd.min.js.map
