/*!
 * bemoje-chess-engine v0.0.0
 * (c) Benjamin MÃ¸ller Jensen
 * Released under the MIT License.
 */
!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports):"function"==typeof define&&define.amd?define(["exports"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self)["bemoje-chess-engine"]={})}(this,(function(t){"use strict";class e{constructor(t,e){this.player=t,this.position=e,this.moves=[]}get game(){return this.player.game}get type(){return this.constructor.name}get hasMoved(){return this.moves.length>0}get color(){return this.player.color}registerMove(t){this.moves.push(t),this.position=t.to.clone()}remove(){this.position=null}isMoveTargetOwnPiece(t){const e=this.game.board.getPieceByPosition(t);return null!==e&&this.player===e.player}isValidMove(t){return this.isMoveTargetOwnPiece(t)}getValidMovePositions(){return this.getMovePositionsWithinBounds().reduce(((t,e)=>{if(Array.isArray(e))for(const i of e){if(!this.isValidMove(i))break;t.push(i)}else this.isValidMove(e)&&t.push(e);return t}),[])}isValidMovePosition(t){return!!this.getValidMovePositions().find((e=>e.compare(t)))}}class i extends e{getMovePositionsWithinBounds(){const t=this.position;return t?t.getAllDiagonalRecursive():[]}}function s(t){const e=[],i=t.length;for(let s=0;s<i;s++)t[s]&&e.push(t[s]);return e}function o(t,e){const i=function(i,s="arg"){if(!e(i))throw new TypeError(`Expected ${s} to be ${t}. ${s}: ${i}`)};return Object.defineProperty(i,"name",{value:e.name.replace(/^is/,"assert")}),i}const n="A".charCodeAt(0);function r(t){return String.fromCharCode(t+n)}function h(t){return(t+1).toString()}function g(t){return t.toUpperCase().charCodeAt(0)-n}function u(t){return Number(t.charAt(0))-1}function a(t){return r(t[0])+h(t[1])}function c(t){return[g(t.charAt(0)),u(t.charAt(1))]}function l(t){return t>=0&&t<=7}function p(t){return l(t[0])&&l(t[1])}function f(t){return 2===t.length&&p(c(t))}const d=o("a positive integer between 0 and 7",l),v=o("an array containing two positive integers between 0 and 7",p),w=o("a valid A1-notation string",f);class R extends Array{constructor(t){super(8),this.game=t;let e=0;for(;e<8;)this[e]=new Array(8).fill(null,0,7),e++}registerMove(t){const e=t.from,i=t.to,s=this[e.y][e.x];this[i.y][i.x]=s,this[e.y][e.x]=null}removePiece(t){const e=t.position;e&&(this[e.y][e.x]=null)}getPieceByXY(t,e){return this[e][t]}getPieceByA1(t){const[e,i]=c(t);return this.getPieceByXY(e,i)}getPieceByPosition(t){return this.getPieceByXY(t.x,t.y)}clone(t=this.game){const e=new R(t);let i=0;for(;i<8;){let t=0;for(;t<8;)e[i][t]=this[i][t],t++;i++}return e}}class M extends Array{static fromA1Notation(t){const e=c(t);return new M(e[0],e[1])}constructor(t,e,i=!1){i||v([t,e],"x and y"),super(2),this[0]=t,this[1]=e}get x(){return this[0]}get y(){return this[1]}get A1(){return a([this.x,this.y])}compare(t){return this.x===t.x&&this.y===t.y}clone(){return new M(this.x,this.y,!0)}toArray(){return[this.x,this.y]}getModulation(t,e){try{return new M(this.x+t,this.y+e)}catch(t){return null}}getUp(){return this.getModulation(0,1)}getDown(){return this.getModulation(0,-1)}getLeft(){return this.getModulation(-1,0)}getRight(){return this.getModulation(1,0)}getUpLeft(){return this.getModulation(-1,1)}getUpRight(){return this.getModulation(1,1)}getDownLeft(){return this.getModulation(-1,-1)}getDownRight(){return this.getModulation(1,-1)}getUpUp(){return this.getModulation(0,2)}getDownDown(){return this.getModulation(0,-2)}getUpUpLeft(){return this.getModulation(-1,2)}getUpUpRight(){return this.getModulation(1,2)}getDownDownLeft(){return this.getModulation(-1,-2)}getDownDownRight(){return this.getModulation(1,-2)}getLeftLeftUp(){return this.getModulation(-2,1)}getLeftLeftDown(){return this.getModulation(-2,-1)}getRightRightUp(){return this.getModulation(2,1)}getRightRightDown(){return this.getModulation(2,-1)}getAllStraight(){return s([this.getUp(),this.getDown(),this.getLeft(),this.getRight()])}getAllDiagonal(){return s([this.getUpLeft(),this.getUpRight(),this.getDownLeft(),this.getDownRight()])}getAllStraightAndDiagonal(){return[...this.getAllStraight(),...this.getAllDiagonal()]}getAllKnightMovePositions(){return s([this.getUpUpLeft(),this.getUpUpRight(),this.getDownDownLeft(),this.getDownDownRight(),this.getLeftLeftUp(),this.getLeftLeftDown(),this.getRightRightUp(),this.getRightRightDown()])}getRecursive(t){const e=[];let i;for(i=this;i=t.call(i);)e.push(i);return e}getUpRecursive(){return this.getRecursive(this.getUp)}getDownRecursive(){return this.getRecursive(this.getDown)}getLeftRecursive(){return this.getRecursive(this.getLeft)}getRightRecursive(){return this.getRecursive(this.getRight)}getUpLeftRecursive(){return this.getRecursive(this.getUpLeft)}getUpRightRecursive(){return this.getRecursive(this.getUpRight)}getDownLeftRecursive(){return this.getRecursive(this.getDownLeft)}getDownRightRecursive(){return this.getRecursive(this.getDownRight)}getAllStraightRecursive(){return[this.getUpRecursive(),this.getDownRecursive(),this.getLeftRecursive(),this.getRightRecursive()]}getAllDiagonalRecursive(){return[this.getUpLeftRecursive(),this.getUpRightRecursive(),this.getDownLeftRecursive(),this.getDownRightRecursive()]}getAllStraightAndDiagonalRecursive(){return[...this.getAllStraightRecursive(),...this.getAllDiagonalRecursive()]}}class m extends e{getMovePositionsWithinBounds(){const t=this.position;if(!t)return[];const e=[];if("white"===this.color){const i=t.getUp();i&&e.push(i);const s=t.getUpUp();s&&!this.hasMoved&&e.push(s);const o=t.getUpLeft();if(o){const t=this.game.board.getPieceByPosition(o);if(t){const i=t.position;i&&"black"===t.color&&e.push(i.clone())}}const n=t.getUpRight();if(n){const t=this.game.board.getPieceByPosition(n);if(t){const i=t.position;i&&"black"===t.color&&e.push(i.clone())}}}else{const i=t.getDown();i&&e.push(i);const s=t.getDownDown();s&&!this.hasMoved&&e.push(s);const o=t.getDownLeft();if(o){const t=this.game.board.getPieceByPosition(o);if(t){const i=t.position;i&&"white"===t.color&&e.push(i.clone())}}const n=t.getDownRight();if(n){const t=this.game.board.getPieceByPosition(n);if(t){const i=t.position;i&&"white"===t.color&&e.push(i.clone())}}}return e}}class A extends e{getMovePositionsWithinBounds(){const t=this.position;return t?t.getAllKnightMovePositions():[]}}class y extends e{getMovePositionsWithinBounds(){const t=this.position;return t?t.getAllStraightAndDiagonalRecursive():[]}}class D extends e{getMovePositionsWithinBounds(){const t=this.position;if(!t)return[];const e=t.getAllStraightRecursive();return"white"===this.color?e.push(M.fromA1Notation("D1")):e.push(M.fromA1Notation("D7")),e}isValidMove(t){return!this.isMoveTargetOwnPiece(t)||this.isValidCastleMove(t)}isValidCastleMove(t){const e=this.game.board.getPieceByPosition(t);return!!e&&("King"===e.type&&!e.hasMoved&&!this.hasMoved)}}class P extends e{getMovePositionsWithinBounds(){const t=this.position;if(!t)return[];const e=t.getAllStraightAndDiagonal();return"white"===this.color?e.push(M.fromA1Notation("A1"),M.fromA1Notation("H1")):e.push(M.fromA1Notation("A7"),M.fromA1Notation("H7")),e}isValidMove(t){return!this.isMoveTargetOwnPiece(t)||this.isValidCastleMove(t)}isValidCastleMove(t){const e=this.game.board.getPieceByPosition(t);return!!e&&("Rook"===e.type&&!e.hasMoved&&!this.hasMoved)}}class U{constructor(t,e){let s,o;if(this.game=t,this.color=e,"white"===e)s="1",o="2";else{if("black"!==e)throw new Error("Invalid color");s="8",o="7"}const n=M.fromA1Notation;this.pieces=[new P(this,n("E"+s)),new y(this,n("D"+s)),new i(this,n("C"+s)),new i(this,n("F"+s)),new A(this,n("B"+s)),new A(this,n("G"+s)),new D(this,n("A"+s)),new D(this,n("H"+s)),new m(this,n("A"+o)),new m(this,n("B"+o)),new m(this,n("C"+o)),new m(this,n("D"+o)),new m(this,n("E"+o)),new m(this,n("F"+o)),new m(this,n("G"+o)),new m(this,n("H"+o))]}}class b{constructor(t,e,i=!1){const s=t.position;if(!s)throw new Error("Cannot move a piece that is not on the board.");if(this.piece=t,this.from=s.clone(),this.to=e.clone(),!i&&!t.isValidMovePosition(e))throw new Error("Invalid move.");{const i=t.game.board.getPieceByPosition(e);i&&i.remove(),t.registerMove(this),t.game.board.registerMove(this)}}}class L{constructor(){this.board=new R(this),this.white=new U(this,"white"),this.black=new U(this,"black"),this.moves=[]}get players(){return[this.black,this.white]}get pieces(){return[...this.black.pieces,...this.white.pieces]}makeMove(t,e,i){return new b(t,e,i)}clone(){const t=new L,e=this.moves,i=e.length;for(let s=0;s<i;s++)t.makeMove(e[s].piece,e[s].to,!0);return t}}t.Bishop=i,t.Board=R,t.Game=L,t.King=P,t.Knight=A,t.Move=b,t.Pawn=m,t.Player=U,t.Position=M,t.Queen=y,t.Rook=D,t.assertValidA1=w,t.assertValidXY=v,t.assertValidXYPoint=d,t.from_1_to_Y=u,t.from_A1_to_XY=c,t.from_A_to_X=g,t.from_XY_to_A1=a,t.from_X_to_A=r,t.from_Y_to_1=h,t.isValidA1=f,t.isValidXY=p,t.isValidXYPoint=l,Object.defineProperty(t,"__esModule",{value:!0})}));
//# sourceMappingURL=index.umd.min.js.map
