{"version":3,"file":"index.umd.min.js","sources":["../src/AbstractPiece.ts","../src/Bishop.ts","../src/util.ts","../src/coordinates.ts","../src/Board.ts","../src/Position.ts","../src/Pawn.ts","../src/Knight.ts","../src/Queen.ts","../src/Rook.ts","../src/King.ts","../src/Player.ts","../src/Move.ts","../src/Game.ts"],"sourcesContent":["import type { Player } from './Player';\nimport type { Position } from './Position';\nimport type { Game } from './Game';\nimport type { Move } from './Move';\n\nexport abstract class Piece {\n  player: Player;\n  position: Position | null;\n  moves: Array<Move>;\n\n  constructor(player: Player, position: Position) {\n    this.player = player;\n    this.position = position;\n    this.moves = [];\n  }\n\n  get game(): Game {\n    return this.player.game;\n  }\n\n  get type(): string {\n    return this.constructor.name;\n  }\n\n  get hasMoved(): boolean {\n    return this.moves.length > 0;\n  }\n\n  get color(): string {\n    return this.player.color;\n  }\n\n  registerMove(move: Move): void {\n    this.moves.push(move);\n    this.position = move.to.clone();\n  }\n\n  remove(): void {\n    this.position = null;\n  }\n\n  protected isMoveTargetOwnPiece(target: Position): boolean {\n    const targetPiece = this.game.board.getPieceByPosition(target);\n    return targetPiece !== null && this.player === targetPiece.player;\n  }\n\n  /**\n   * Returns whether a move to a position is a valid move.\n   */\n  protected isValidMove(target: Position): boolean {\n    return this.isMoveTargetOwnPiece(target);\n  }\n\n  /**\n   * Returns a Position array with all piece-specific move positions within bounds of the board.\n   */\n  protected abstract getMovePositionsWithinBounds(): Array<\n    Position | Array<Position>\n  >;\n\n  /**\n   * Returns a Position array with all valid moves.\n   */\n  getValidMovePositions(): Array<Position> {\n    return this.getMovePositionsWithinBounds().reduce((accum, item) => {\n      if (Array.isArray(item)) {\n        for (const pos of item) {\n          if (pos && this.isValidMove(pos)) accum.push(pos);\n          else break;\n        }\n      } else if (this.isValidMove(item)) {\n        accum.push(item);\n      }\n      return accum;\n    }, []);\n  }\n\n  isValidMovePosition(target: Position): boolean {\n    return !!this.getValidMovePositions().find((position: Position) => {\n      return position.compare(target);\n    });\n  }\n}\n","import { Piece } from './AbstractPiece';\nimport type { Position } from './Position';\n\nexport class Bishop extends Piece {\n  protected getMovePositionsWithinBounds(): Array<Position | Array<Position>> {\n    const pos = this.position;\n    return pos ? pos.getAllDiagonalRecursive() : [];\n  }\n}\n","/**\n * Removes elements of a given array if they do not evaluate to true.\n */\nexport function arrClean(arr: Array<any>): Array<any> {\n  const res = [];\n  const l = arr.length;\n  for (let i = 0; i < l; i++) {\n    if (arr[i]) {\n      res.push(arr[i]);\n    }\n  }\n  return res;\n}\n\n/**\n * Returns the numeric difference between to numbers.\n */\nexport function numericDifference(n1: number, n2: number): number {\n  const dist = n1 - n2;\n  return dist < 0 ? dist * -1 : dist;\n}\n\n/**\n * Returns an assertion function that expects [string] 'expectedToBe' evaluated by [Function] 'validate'\n */\nexport function createAssertFunction(\n  expectedToBe: string,\n  validate: (arg: any) => boolean,\n): (arg: any, name?: string) => void {\n  const f = function (arg: any, name = 'arg') {\n    if (!validate(arg)) {\n      throw new TypeError(\n        `Expected ${name} to be ${expectedToBe}. ${name}: ${arg}`,\n      );\n    }\n  };\n  Object.defineProperty(f, 'name', {\n    value: validate.name.replace(/^is/, 'assert'),\n  });\n  return f;\n}\n","import { createAssertFunction } from './util';\nimport type { Position } from './Position';\n\nconst A_CHAR_CODE = 'A'.charCodeAt(0);\n\n/**\n * Converts the first value of an XY-coordinate to A1-notation.\n */\nexport function from_X_to_A(x: number): string {\n  return String.fromCharCode(x + A_CHAR_CODE);\n}\n\n/**\n * Converts the second value of an XY-coordinate to A1-notation.\n */\nexport function from_Y_to_1(y: number): string {\n  return (y + 1).toString();\n}\n\n/**\n * Converts the first character of A1-notation to the first value of an XY-coordinate.\n */\nexport function from_A_to_X(a: string): number {\n  return a.toUpperCase().charCodeAt(0) - A_CHAR_CODE;\n}\n\n/**\n * Converts the second character of A1-notation to the second value of an XY-coordinate.\n */\nexport function from_1_to_Y(n: string): number {\n  return Number(n.charAt(0)) - 1;\n}\n\n/**\n * Converts a XY-coordinate-array or a Position type (extends Array) to an A1-notation string.\n */\nexport function from_XY_to_A1(pos: Array<number> | Position): string {\n  return from_X_to_A(pos[0]) + from_Y_to_1(pos[1]);\n}\n\n/**\n * Converts an A1-notation string to a XY-coordinate-array.\n */\nexport function from_A1_to_XY(a1: string): Array<number> {\n  return [from_A_to_X(a1.charAt(0)), from_1_to_Y(a1.charAt(1))];\n}\n\n/**\n * Returns whether the argument is a positive integer where 0 <= arg <= 7.\n */\nexport function isValidXYPoint(n: number): boolean {\n  return n >= 0 && n <= 7;\n}\n\n/**\n * Returns whether both points in an XY-coordinate is a positive integer where 0 <= arg <= 7.\n */\nexport function isValidXY(pos: Array<number> | Position): boolean {\n  return isValidXYPoint(pos[0]) && isValidXYPoint(pos[1]);\n}\n\n/**\n * Returns whether a string is valid A1-notation.\n */\nexport function isValidA1(a1: string): boolean {\n  return a1.length === 2 && isValidXY(from_A1_to_XY(a1));\n}\n\n/**\n * Throws a TypeError if the argument is not a valid XY-coordinate point.\n * @see isValidXYPoint\n *\n * @function assertValidXYPoint\n * @throws {TypeError}\n */\nexport const assertValidXYPoint = createAssertFunction(\n  'a positive integer between 0 and 7',\n  isValidXYPoint,\n);\n\n/**\n * Throws a TypeError if the argument is not a valid XY-coordinate.\n * @see isValidXY\n *\n * @function assertValidXY\n * @throws {TypeError}\n */\nexport const assertValidXY = createAssertFunction(\n  'an array containing two positive integers between 0 and 7',\n  isValidXY,\n);\n\n/**\n * Throws a TypeError if the argument is not valid A1-notation.\n * @see isValidA1\n *\n * @function assertValidA1\n * @throws {TypeError}\n */\nexport const assertValidA1 = createAssertFunction(\n  'a valid A1-notation string',\n  isValidA1,\n);\n","import { from_A1_to_XY } from './coordinates';\n\nimport type { Position } from './Position';\nimport type { Game } from './Game';\nimport type { Move } from './Move';\nimport type { Piece } from './AbstractPiece';\n\nexport class Board {\n  game: Game;\n  grid: Array<Array<Piece | null>>;\n\n  constructor(game: Game) {\n    this.game = game;\n    this.grid = [];\n    let i = 0;\n    while (i < 8) {\n      this.grid.push(new Array(8).fill(null, 0, 7));\n      i++;\n    }\n  }\n\n  /**\n   * Updates the board instance based on the information contained within a provided Move instance.\n   */\n  registerMove(move: Move): void {\n    const currPos = move.from;\n    const newPos = move.to;\n    const piece = this.grid[currPos.y][currPos.x];\n    this.grid[newPos.y][newPos.x] = piece;\n    this.grid[currPos.y][currPos.x] = null;\n  }\n\n  /**\n   * Removes a piece from the board.\n   */\n  removePiece(piece: Piece): void {\n    const pos = piece.position;\n    if (pos) this.grid[pos.y][pos.x] = null;\n  }\n\n  /**\n   * Returns the piece at the given XY-coordinates or null if no piece is found there.\n   */\n  getPieceByXY(x: number, y: number): Piece | null {\n    return this.grid[y][x];\n  }\n\n  /**\n   * Returns the piece at the given A1-notation-coordinates or null if no piece is found there.\n   */\n  getPieceByA1(a1: string): Piece | null {\n    const [x, y] = from_A1_to_XY(a1);\n    return this.getPieceByXY(x, y);\n  }\n\n  /**\n   * Returns the piece at the given Position or null if no piece is found there.\n   */\n  getPieceByPosition(position: Position): Piece | null {\n    return this.getPieceByXY(position.x, position.y);\n  }\n\n  // clone(game: Game = this.game): Board {\n  //   const board = new Board(game);\n  //   let i = 0;\n  //   while (i < 8) {\n  //     let j = 0;\n  //     while (j < 8) {\n  //       board[i][j] = this.grid[i][j];\n  //       j++;\n  //     }\n  //     i++;\n  //   }\n  //   return board;\n  // }\n}\n","import { from_A1_to_XY, from_XY_to_A1, assertValidXY } from './coordinates';\nimport { arrClean } from './util';\n\nexport class Position extends Array {\n  /**\n   * Returns a new Position instance based on A1-notation input.\n   */\n  static fromA1Notation(a1: string): Position {\n    const xy = from_A1_to_XY(a1);\n    return new Position(xy[0], xy[1]);\n  }\n\n  /**\n   * @param x - a positive integer between 0 and 7 both inclusive.\n   * @param y - a positive integer between 0 and 7 both inclusive.\n   */\n  constructor(x: number, y: number, _skipValidation = false) {\n    if (!_skipValidation) {\n      assertValidXY([x, y], 'x and y');\n    }\n    super(2);\n    this[0] = x;\n    this[1] = y;\n  }\n\n  /**\n   * Returns the first value of the XY-point that the instance describes.\n   */\n  get x(): number {\n    return this[0];\n  }\n\n  /**\n   * Returns the second value of the XY-point that the instance describes.\n   */\n  get y(): number {\n    return this[1];\n  }\n\n  /**\n   * Returns the board position in A1-notation.\n   */\n  get A1(): string {\n    return from_XY_to_A1([this.x, this.y]);\n  }\n\n  /**\n   * Deep-equality-compares the Position instance to another Position instance.\n   */\n  compare(position: Position): boolean {\n    return this.x === position.x && this.y === position.y;\n  }\n\n  /**\n   * Returns a clone of the instance.\n   * Out of bounds -validation is skipped.\n   */\n  clone(): Position {\n    return new Position(this.x, this.y, true);\n  }\n\n  /**\n   * Returns the instance as a normal array.\n   */\n  toArray(): Array<number> {\n    return [this.x, this.y];\n  }\n\n  /**\n   * Modulates the XY-position coordinate and returns a new Position instance equivalent to it.\n   */\n  private getModulation(xBy: number, yBy: number): Position | null {\n    try {\n      return new Position(this.x + xBy, this.y + yBy);\n    } catch (e) {\n      return null;\n    }\n  }\n\n  /**\n   * Returns a new Position instance that is moved up by 1 from the position on the board that this instance describes.\n   */\n  getUp(): Position | null {\n    return this.getModulation(0, 1);\n  }\n\n  /**\n   * Returns a new Position instance that is moved down by 1 from the position on the board that this instance describes.\n   */\n  getDown(): Position | null {\n    return this.getModulation(0, -1);\n  }\n\n  /**\n   * Returns a new Position instance that is moved left by 1 from the position on the board that this instance describes.\n   */\n  getLeft(): Position | null {\n    return this.getModulation(-1, 0);\n  }\n\n  /**\n   * Returns a new Position instance that is moved right by 1 from the position on the board that this instance describes.\n   */\n  getRight(): Position | null {\n    return this.getModulation(1, 0);\n  }\n\n  /**\n   * Returns a new Position instance that is moved up by 1 and left by 1 from the position on the board that this instance describes.\n   */\n  getUpLeft(): Position | null {\n    return this.getModulation(-1, 1);\n  }\n\n  /**\n   * Returns a new Position instance that is moved up by 1 and right by 1 from the position on the board that this instance describes.\n   */\n  getUpRight(): Position | null {\n    return this.getModulation(1, 1);\n  }\n\n  /**\n   * Returns a new Position instance that is moved down by 1 and left by 1 from the position on the board that this instance describes.\n   */\n  getDownLeft(): Position | null {\n    return this.getModulation(-1, -1);\n  }\n\n  /**\n   * Returns a new Position instance that is moved down by 1 and right by 1 from the position on the board that this instance describes.\n   */\n  getDownRight(): Position | null {\n    return this.getModulation(1, -1);\n  }\n\n  /**\n   * Returns a new Position instance that is moved up by 2 from the position on the board that this instance describes.\n   */\n  getUpUp(): Position | null {\n    return this.getModulation(0, 2);\n  }\n\n  /**\n   * Returns a new Position instance that is moved down by 2 from the position on the board that this instance describes.\n   */\n  getDownDown(): Position | null {\n    return this.getModulation(0, -2);\n  }\n\n  /**\n   * Returns a new Position instance that is moved up by 2 and left by 1 from the position on the board that this instance describes.\n   */\n  getUpUpLeft(): Position | null {\n    return this.getModulation(-1, 2);\n  }\n\n  /**\n   * Returns a new Position instance that is moved up by 2 and right by 1 from the position on the board that this instance describes.\n   */\n  getUpUpRight(): Position | null {\n    return this.getModulation(1, 2);\n  }\n\n  /**\n   * Returns a new Position instance that is moved down by 2 and left by 1 from the position on the board that this instance describes.\n   */\n  getDownDownLeft(): Position | null {\n    return this.getModulation(-1, -2);\n  }\n\n  /**\n   * Returns a new Position instance that is moved down by 2 and right by 1 from the position on the board that this instance describes.\n   */\n  getDownDownRight(): Position | null {\n    return this.getModulation(1, -2);\n  }\n\n  /**\n   * Returns a new Position instance that is moved left by 2 and up by 1 from the position on the board that this instance describes.\n   */\n  getLeftLeftUp(): Position | null {\n    return this.getModulation(-2, 1);\n  }\n\n  /**\n   * Returns a new Position instance that is moved left by 2 and up by 1 from the position on the board that this instance describes.\n   */\n  getLeftLeftDown(): Position | null {\n    return this.getModulation(-2, -1);\n  }\n\n  /**\n   * Returns a new Position instance that is moved right by 2 and up by 1 from the position on the board that this instance describes.\n   */\n  getRightRightUp(): Position | null {\n    return this.getModulation(2, 1);\n  }\n\n  /**\n   * Returns a new Position instance that is moved right by 2 and down by 1 from the position on the board that this instance describes.\n   */\n  getRightRightDown(): Position | null {\n    return this.getModulation(2, -1);\n  }\n\n  /**\n   * Returns an array of new Position instances that are moved by 1 in all straight (horizontal and vertical) directions.\n   */\n  getAllStraight(): Array<Position> {\n    return arrClean([\n      this.getUp(),\n      this.getDown(),\n      this.getLeft(),\n      this.getRight(),\n    ]);\n  }\n\n  /**\n   * Returns an array of new Position instances that are moved by 1 in all diagonal directions.\n   */\n  getAllDiagonal(): Array<Position> {\n    return arrClean([\n      this.getUpLeft(),\n      this.getUpRight(),\n      this.getDownLeft(),\n      this.getDownRight(),\n    ]);\n  }\n\n  /**\n   * Returns an array of new Position instances that are moved by 1 in all straight (horizontal and vertical) and diagonal directions.\n   */\n  getAllStraightAndDiagonal(): Array<Position> {\n    return [...this.getAllStraight(), ...this.getAllDiagonal()];\n  }\n\n  /**\n   * Returns an array of new Position instances that are moved one time equivalent of all legal knight-piece moves.\n   */\n  getAllKnightMovePositions(): Array<Position> {\n    return arrClean([\n      this.getUpUpLeft(),\n      this.getUpUpRight(),\n      this.getDownDownLeft(),\n      this.getDownDownRight(),\n      this.getLeftLeftUp(),\n      this.getLeftLeftDown(),\n      this.getRightRightUp(),\n      this.getRightRightDown(),\n    ]);\n  }\n\n  /**\n   * Returns an array of new Position instances that are moved by a provided modulator function recursively until the\n   * modulator's returned Position instance becomes out of bounds of the board.\n   */\n  private getRecursive(modulator: () => Position | null): Array<Position> {\n    const res = [];\n    let pos: Position | null;\n    pos = this;\n    while ((pos = modulator.call(pos))) {\n      res.push(pos);\n    }\n    return res;\n  }\n\n  /**\n   * Returns an array of new Position instances that are the result of recursively moving up by 1 from the position on\n   * the board that this instance describes until the resulting Position instance becomes out of bounds of the board.\n   */\n  getUpRecursive(): Array<Position> {\n    return this.getRecursive(this.getUp);\n  }\n\n  /**\n   * Returns an array of new Position instances that are the result of recursively moving down by 1 from the position on\n   * the board that this instance describes until the resulting Position instance becomes out of bounds of the board.\n   */\n  getDownRecursive(): Array<Position> {\n    return this.getRecursive(this.getDown);\n  }\n\n  /**\n   * Returns an array of new Position instances that are the result of recursively moving left by 1 from the position on\n   * the board that this instance describes until the resulting Position instance becomes out of bounds of the board.\n   */\n  getLeftRecursive(): Array<Position> {\n    return this.getRecursive(this.getLeft);\n  }\n\n  /**\n   * Returns an array of new Position instances that are the result of recursively moving right by 1 from the position on\n   * the board that this instance describes until the resulting Position instance becomes out of bounds of the board.\n   */\n  getRightRecursive(): Array<Position> {\n    return this.getRecursive(this.getRight);\n  }\n\n  /**\n   * Returns an array of new Position instances that are the result of recursively moving up by 1 and left by 1 from the\n   * position on the board that this instance describes until the resulting Position instance becomes out of bounds of\n   * the board.\n   */\n  getUpLeftRecursive(): Array<Position> {\n    return this.getRecursive(this.getUpLeft);\n  }\n\n  /**\n   * Returns an array of new Position instances that are the result of recursively moving up by 1 and right by 1 from the\n   * position on the board that this instance describes until the resulting Position instance becomes out of bounds of\n   * the board.\n   */\n  getUpRightRecursive(): Array<Position> {\n    return this.getRecursive(this.getUpRight);\n  }\n\n  /**\n   * Returns an array of new Position instances that are the result of recursively moving down by 1 and left by 1 from the\n   * position on the board that this instance describes until the resulting Position instance becomes out of bounds of\n   * the board.\n   */\n  getDownLeftRecursive(): Array<Position> {\n    return this.getRecursive(this.getDownLeft);\n  }\n\n  /**\n   * Returns an array of new Position instances that are the result of recursively moving down by 1 and right by 1 from the\n   * position on the board that this instance describes until the resulting Position instance becomes out of bounds of\n   * the board.\n   */\n  getDownRightRecursive(): Array<Position> {\n    return this.getRecursive(this.getDownRight);\n  }\n\n  /**\n   * Returns an array of new Position instances that are the result of recursively moving by 1 in all straight\n   * (horizontal and vertical) directions from the position on the board that this instance describes until the\n   * resulting Position instance becomes out of bounds of the board.\n   */\n  getAllStraightRecursive(): Array<Array<Position>> {\n    return [\n      this.getUpRecursive(),\n      this.getDownRecursive(),\n      this.getLeftRecursive(),\n      this.getRightRecursive(),\n    ];\n  }\n\n  /**\n   * Returns an array of new Position instances that are the result of recursively moving by 1 in all diagonal\n   * directions. from the position on the board that this instance describes until the resulting Position instance\n   * becomes out of bounds of the board.\n   */\n  getAllDiagonalRecursive(): Array<Array<Position>> {\n    return [\n      this.getUpLeftRecursive(),\n      this.getUpRightRecursive(),\n      this.getDownLeftRecursive(),\n      this.getDownRightRecursive(),\n    ];\n  }\n\n  /**\n   * Returns an array of new Position instances that are the result of recursively moving by 1 in all straight\n   * (horizontal and vertical) and diagonal directions from the position on the board that this instance describes until\n   * the resulting Position instance becomes out of bounds of the board.\n   */\n  getAllStraightAndDiagonalRecursive(): Array<Array<Position>> {\n    return [\n      ...this.getAllStraightRecursive(),\n      ...this.getAllDiagonalRecursive(),\n    ];\n  }\n}\n","import { Piece } from './AbstractPiece';\nimport type { Position } from './Position';\n\nexport class Pawn extends Piece {\n  protected getMovePositionsWithinBounds(): Array<Position | Array<Position>> {\n    const pos = this.position;\n    if (!pos) return [];\n    const res = [];\n\n    if (this.color === 'white') {\n      const upPos = pos.getUp();\n      if (upPos) {\n        res.push(upPos);\n      }\n\n      const upUpPos = pos.getUpUp();\n      if (upUpPos && !this.hasMoved) {\n        res.push(upUpPos);\n      }\n\n      const upLeftPos = pos.getUpLeft();\n      if (upLeftPos) {\n        const diagLeftPiece = this.game.board.getPieceByPosition(upLeftPos);\n        if (diagLeftPiece) {\n          const diagLeftPos = diagLeftPiece.position;\n          if (diagLeftPos && diagLeftPiece.color === 'black') {\n            res.push(diagLeftPos.clone());\n          }\n        }\n      }\n\n      const upRightPos = pos.getUpRight();\n      if (upRightPos) {\n        const diagRightPiece = this.game.board.getPieceByPosition(upRightPos);\n        if (diagRightPiece) {\n          const diagLeftPos = diagRightPiece.position;\n          if (diagLeftPos && diagRightPiece.color === 'black') {\n            res.push(diagLeftPos.clone());\n          }\n        }\n      }\n    } else {\n      const downPos = pos.getDown();\n      if (downPos) {\n        res.push(downPos);\n      }\n\n      const downDownPos = pos.getDownDown();\n      if (downDownPos && !this.hasMoved) {\n        res.push(downDownPos);\n      }\n\n      const downLeftPos = pos.getDownLeft();\n      if (downLeftPos) {\n        const diagLeftPiece = this.game.board.getPieceByPosition(downLeftPos);\n        if (diagLeftPiece) {\n          const diagLeftPos = diagLeftPiece.position;\n          if (diagLeftPos && diagLeftPiece.color === 'white') {\n            res.push(diagLeftPos.clone());\n          }\n        }\n      }\n\n      const downRightPos = pos.getDownRight();\n      if (downRightPos) {\n        const diagRightPiece = this.game.board.getPieceByPosition(downRightPos);\n        if (diagRightPiece) {\n          const diagLeftPos = diagRightPiece.position;\n          if (diagLeftPos && diagRightPiece.color === 'white') {\n            res.push(diagLeftPos.clone());\n          }\n        }\n      }\n    }\n    return res;\n  }\n}\n","import { Piece } from './AbstractPiece';\nimport type { Position } from './Position';\n\nexport class Knight extends Piece {\n  protected getMovePositionsWithinBounds(): Array<Position | Array<Position>> {\n    const pos = this.position;\n    return pos ? pos.getAllKnightMovePositions() : [];\n  }\n}\n","import { Piece } from './AbstractPiece';\nimport type { Position } from './Position';\n\nexport class Queen extends Piece {\n  protected getMovePositionsWithinBounds(): Array<Position | Array<Position>> {\n    const pos = this.position;\n    return pos ? pos.getAllStraightAndDiagonalRecursive() : [];\n  }\n}\n","import { Piece } from './AbstractPiece';\nimport { Position } from './Position';\n\nexport class Rook extends Piece {\n  protected getMovePositionsWithinBounds(): Array<Position | Array<Position>> {\n    const pos = this.position;\n    if (!pos) return [];\n    const res = pos.getAllStraightRecursive();\n    if (this.color === 'white') {\n      res.push(Position.fromA1Notation('D1'));\n    } else {\n      res.push(Position.fromA1Notation('D7'));\n    }\n    return res;\n  }\n\n  protected isValidMove(target: Position): boolean {\n    return this.isMoveTargetOwnPiece(target)\n      ? this.isValidCastleMove(target)\n      : true;\n  }\n\n  private isValidCastleMove(target: Position): boolean {\n    const targetPiece = this.game.board.getPieceByPosition(target);\n    return targetPiece\n      ? targetPiece.type === 'King' && !targetPiece.hasMoved && !this.hasMoved\n      : false;\n  }\n}\n","import { Piece } from './AbstractPiece';\nimport { Position } from './Position';\n\nexport class King extends Piece {\n  protected getMovePositionsWithinBounds(): Array<Position | Array<Position>> {\n    const pos = this.position;\n    if (!pos) return [];\n    const res = pos.getAllStraightAndDiagonal();\n    if (this.color === 'white') {\n      res.push(Position.fromA1Notation('A1'), Position.fromA1Notation('H1'));\n    } else {\n      res.push(Position.fromA1Notation('A7'), Position.fromA1Notation('H7'));\n    }\n    return res;\n  }\n\n  protected isValidMove(target: Position): boolean {\n    return this.isMoveTargetOwnPiece(target)\n      ? this.isValidCastleMove(target)\n      : true;\n  }\n\n  private isValidCastleMove(target: Position): boolean {\n    const targetPiece = this.game.board.getPieceByPosition(target);\n    return targetPiece\n      ? targetPiece.type === 'Rook' && !targetPiece.hasMoved && !this.hasMoved\n      : false;\n  }\n}\n","import { Position } from './Position';\nimport { Pawn } from './Pawn';\nimport { Knight } from './Knight';\nimport { Bishop } from './Bishop';\nimport { Queen } from './Queen';\nimport { Rook } from './Rook';\nimport { King } from './King';\nimport type { Piece } from './AbstractPiece';\nimport type { Game } from './Game';\n\nexport class Player {\n  game: Game;\n  color: string;\n  pieces: Array<Piece>;\n\n  constructor(game: Game, color: string) {\n    this.game = game;\n    this.color = color;\n\n    let row1: string, row2: string;\n\n    if (color === 'white') {\n      row1 = '1';\n      row2 = '2';\n    } else if (color === 'black') {\n      row1 = '8';\n      row2 = '7';\n    } else {\n      throw new Error('Invalid color');\n    }\n\n    const pos = Position.fromA1Notation;\n\n    this.pieces = [\n      new King(this, pos('E' + row1)),\n      new Queen(this, pos('D' + row1)),\n      new Bishop(this, pos('C' + row1)),\n      new Bishop(this, pos('F' + row1)),\n      new Knight(this, pos('B' + row1)),\n      new Knight(this, pos('G' + row1)),\n      new Rook(this, pos('A' + row1)),\n      new Rook(this, pos('H' + row1)),\n      new Pawn(this, pos('A' + row2)),\n      new Pawn(this, pos('B' + row2)),\n      new Pawn(this, pos('C' + row2)),\n      new Pawn(this, pos('D' + row2)),\n      new Pawn(this, pos('E' + row2)),\n      new Pawn(this, pos('F' + row2)),\n      new Pawn(this, pos('G' + row2)),\n      new Pawn(this, pos('H' + row2)),\n    ];\n  }\n}\n","import type { Piece } from './AbstractPiece';\nimport type { Position } from './Position';\n\nexport class Move {\n  piece: Piece;\n  from: Position;\n  to: Position;\n\n  constructor(piece: Piece, to: Position, _skipValidation = false) {\n    const pos = piece.position;\n    if (!pos) throw new Error('Cannot move a piece that is not on the board.');\n\n    this.piece = piece;\n    this.from = pos.clone();\n    this.to = to.clone();\n\n    if (_skipValidation || piece.isValidMovePosition(to)) {\n      const targetPiece = piece.game.board.getPieceByPosition(to);\n      if (targetPiece) targetPiece.remove();\n      piece.registerMove(this);\n      piece.game.board.registerMove(this);\n    } else {\n      throw new Error('Invalid move.');\n    }\n  }\n}\n","import { Board } from './Board';\nimport { Player } from './Player';\nimport { Move } from './Move';\nimport type { Piece } from './AbstractPiece';\nimport type { Position } from './Position';\n\nexport class Game {\n  board: Board;\n  white: Player;\n  black: Player;\n  moves: Array<Move>;\n\n  constructor() {\n    this.board = new Board(this);\n    this.white = new Player(this, 'white');\n    this.black = new Player(this, 'black');\n    this.moves = [];\n  }\n\n  get players(): Array<Player> {\n    return [this.black, this.white];\n  }\n\n  get pieces(): Array<Piece> {\n    return [...this.black.pieces, ...this.white.pieces];\n  }\n\n  makeMove(piece: Piece, to: Position, _skipValidation?: boolean): Move {\n    return new Move(piece, to, _skipValidation);\n  }\n\n  clone(): Game {\n    const game = new Game();\n    const moves = this.moves;\n    const l = moves.length;\n    for (let i = 0; i < l; i++) {\n      game.makeMove(moves[i].piece, moves[i].to, true);\n    }\n    return game;\n  }\n}\n"],"names":["Piece","[object Object]","player","position","this","moves","game","type","constructor","name","hasMoved","length","color","move","push","to","clone","target","targetPiece","board","getPieceByPosition","isMoveTargetOwnPiece","getMovePositionsWithinBounds","reduce","accum","item","Array","isArray","pos","isValidMove","getValidMovePositions","find","compare","Bishop","getAllDiagonalRecursive","arrClean","arr","res","l","i","createAssertFunction","expectedToBe","validate","f","arg","TypeError","Object","defineProperty","value","replace","A_CHAR_CODE","charCodeAt","from_X_to_A","x","String","fromCharCode","from_Y_to_1","y","toString","from_A_to_X","a","toUpperCase","from_1_to_Y","n","Number","charAt","from_XY_to_A1","from_A1_to_XY","a1","isValidXYPoint","isValidXY","isValidA1","assertValidXYPoint","assertValidXY","assertValidA1","Board","grid","fill","currPos","from","newPos","piece","getPieceByXY","Position","xy","_skipValidation","super","A1","xBy","yBy","e","getModulation","getUp","getDown","getLeft","getRight","getUpLeft","getUpRight","getDownLeft","getDownRight","getAllStraight","getAllDiagonal","getUpUpLeft","getUpUpRight","getDownDownLeft","getDownDownRight","getLeftLeftUp","getLeftLeftDown","getRightRightUp","getRightRightDown","modulator","call","getRecursive","getUpRecursive","getDownRecursive","getLeftRecursive","getRightRecursive","getUpLeftRecursive","getUpRightRecursive","getDownLeftRecursive","getDownRightRecursive","getAllStraightRecursive","Pawn","upPos","upUpPos","getUpUp","upLeftPos","diagLeftPiece","diagLeftPos","upRightPos","diagRightPiece","downPos","downDownPos","getDownDown","downLeftPos","downRightPos","Knight","getAllKnightMovePositions","Queen","getAllStraightAndDiagonalRecursive","Rook","fromA1Notation","isValidCastleMove","King","getAllStraightAndDiagonal","Player","row1","row2","Error","pieces","Move","isValidMovePosition","remove","registerMove","Game","white","black","players","makeMove"],"mappings":"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"}