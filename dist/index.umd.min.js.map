{"version":3,"file":"index.umd.min.js","sources":["../src/AbstractPiece.ts","../src/Bishop.ts","../src/util.ts","../src/Position.ts","../src/coordinates.ts","../src/Board.ts","../src/King.ts","../src/Knight.ts","../src/Move.ts","../src/Pawn.ts","../src/Queen.ts","../src/Rook.ts","../src/Player.ts","../src/Game.ts"],"sourcesContent":["import type { Player } from './Player';\nimport type { Position } from './Position';\nimport type { Game } from './Game';\nimport type { Move } from './Move';\n\nexport abstract class Piece {\n  public player: Player;\n  public index: number;\n  public position: Position | null;\n  public moveCount: number;\n\n  public constructor(player: Player, index: number, position: Position) {\n    this.player = player;\n    this.index = index;\n    this.position = position;\n    this.moveCount = 0;\n    this.player.game.board.setPiece(this);\n  }\n\n  /**\n   * Returns the Game instance that this Piece is associated with.\n   */\n  public get game(): Game {\n    return this.player.game;\n  }\n\n  /**\n   * Returns the class name of the Piece.\n   */\n  public get type(): string {\n    return this.constructor.name;\n  }\n\n  /**\n   * Returns whether or not this Piece has made any moves yet.\n   */\n  public get hasMoved(): boolean {\n    return this.moveCount > 0;\n  }\n\n  /**\n   * Returns the player color of the Player instance that this Piece belongs to.\n   */\n  public get color(): string {\n    return this.player.color;\n  }\n\n  /**\n   * Returns whether this Piece is still on the board.\n   */\n  public get isTaken(): boolean {\n    return this.position === null;\n  }\n\n  /**\n   * Returns an array of Move instances that represent moves made by this Piece.\n   */\n  public get moves(): Move[] {\n    return this.player.game.moves.filter((move) => {\n      return move.piece === this;\n    });\n  }\n\n  /**\n   * Increments the moveCount number property and sets the position property.\n   */\n  public registerMove(move: Move): void {\n    this.moveCount++;\n    this.position = move.to.clone();\n  }\n\n  /**\n   * Sets the position property to null, which means that this Piece is no longer on the board.\n   */\n  public remove(): void {\n    this.position = null;\n  }\n\n  /**\n   * Returns whether there is a 'friendly' Piece at a given Position.\n   */\n  protected isMoveTargetOwnPiece(target: Position): boolean {\n    const targetPiece = this.game.board.getPieceByPosition(target);\n    return targetPiece !== null && this.player === targetPiece.player;\n  }\n\n  /**\n   * Returns whether it is this Piece's Player's turn to move.\n   */\n  protected get isOwnTurn(): boolean {\n    return this.game.activePlayer === this.player;\n  }\n\n  /**\n   * Returns a Position array with all piece-specific move positions within bounds of the board.\n   */\n  protected abstract getMovePositionsWithinBounds(): Array<\n    Position | Array<Position>\n  >;\n\n  /**\n   * Iterates all valid move Position instances for this Piece.\n   *\n   * @param f - a callback function to invoke for each valid move position. If it returns true, iteration ends.\n   * @returns true if iteration was ended before completion.\n   */\n  public forEachValidMovePosition(\n    f: (position: Position) => boolean | void,\n  ): boolean | void {\n    if (this.isOwnTurn) {\n      const positions = this.getMovePositionsWithinBounds();\n      for (let i = 0; i < positions.length; i++) {\n        const item = positions[i];\n        if (Array.isArray(item)) {\n          // item is an array of positions where the array represents a move-direction. Used for pieces that can move\n          // further than by one slot on the game board.\n          for (let j = 0; j < item.length; j++) {\n            if (item[j] && this.isMoveTargetOwnPiece(item[j])) {\n              if (f(item[j])) {\n                return true;\n              }\n            } else {\n              // an own piece is in the way, so all following positions for the current direction will always be invalid.\n              break;\n            }\n          }\n        } else if (this.isMoveTargetOwnPiece(item)) {\n          if (f(item)) {\n            return true;\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Returns whether a move to a target position is a castling move.\n   */\n  public isCastleMove(_target: Position): boolean {\n    return false;\n    _target; // bypasses typescript warning\n  }\n\n  /**\n   * Returns whether a move to a position is a valid move.\n   */\n  public isValidMove(target: Position): boolean {\n    if (this.isCastleMove(target)) return true;\n    let res = false;\n    this.forEachValidMovePosition((position) => {\n      if (position.compare(target)) {\n        res = true;\n        // end iteration\n        return true;\n      } else return;\n    });\n    return res;\n  }\n}\n","import { Piece } from './AbstractPiece';\nimport type { Position } from './Position';\n\nexport class Bishop extends Piece {\n  /**\n   * Returns a Position array with all piece-specific move positions within bounds of the board.\n   */\n  protected getMovePositionsWithinBounds(): Array<Position | Array<Position>> {\n    const pos = this.position;\n    return pos ? pos.getAllDiagonalRecursive() : [];\n  }\n}\n","import type { Position } from './Position';\n\n/**\n * Removes elements of a given array if they do not evaluate to true.\n */\nexport function arrClean(arr: Array<Position | null>): Array<Position> {\n  const res = [];\n  const l = arr.length;\n  for (let i = 0; i < l; i++) {\n    const pos = arr[i];\n    if (pos) {\n      res.push(pos);\n    }\n  }\n  return res;\n}\n\n/**\n * Returns the numeric difference between to numbers.\n */\nexport function numericDifference(n1: number, n2: number): number {\n  const dist = n1 - n2;\n  return dist < 0 ? dist * -1 : dist;\n}\n\n/**\n * Returns an assertion function that expects [string] 'expectedToBe' evaluated by [Function] 'validate'\n */\nexport function createAssertFunction<T>(\n  expectedToBe: string,\n  validate: (arg: T) => boolean,\n): (arg: T, name?: string) => void {\n  const f = function (arg: T, name = 'arg') {\n    if (!validate(arg)) {\n      throw new TypeError(\n        `Expected ${name} to be ${expectedToBe}. ${name}: ${arg}`,\n      );\n    }\n  };\n  Object.defineProperty(f, 'name', {\n    value: validate.name.replace(/^is/, 'assert'),\n  });\n  return f;\n}\n\n/**\n * Returns whether a number is an even number.\n */\nexport function isEven(n: number): boolean {\n  return n % 2 == 0;\n}\n","import { from_A1_to_XY, from_XY_to_A1, assertValidXY } from './coordinates';\nimport { arrClean } from './util';\n\nexport class Position {\n  public x: number;\n  public y: number;\n  /**\n   * Returns a new Position instance based on A1-notation input.\n   */\n  public static fromA1(a1: string): Position {\n    const xy = from_A1_to_XY(a1);\n    return new Position(xy[0], xy[1]);\n  }\n\n  /**\n   * @param x - a positive integer between 0 and 7 both inclusive.\n   * @param y - a positive integer between 0 and 7 both inclusive.\n   */\n  public constructor(x: number, y: number, skipValidation = false) {\n    if (!skipValidation) {\n      assertValidXY([x, y], 'x and y');\n    }\n    this.x = x;\n    this.y = y;\n  }\n\n  /**\n   * Returns the board position in A1-notation.\n   */\n  public get A1(): string {\n    return from_XY_to_A1([this.x, this.y]);\n  }\n\n  /**\n   * Deep-equality-compares the Position instance to another Position instance.\n   */\n  public compare(position: Position): boolean {\n    return this.x === position.x && this.y === position.y;\n  }\n\n  /**\n   * Returns a clone of the instance.\n   * Out of bounds -validation is skipped.\n   */\n  public clone(): Position {\n    return new Position(this.x, this.y, true);\n  }\n\n  /**\n   * Returns the instance as a normal array.\n   */\n  public toArray(): Array<number> {\n    return [this.x, this.y];\n  }\n\n  /**\n   * Modulates the XY-position coordinate and returns a new Position instance equivalent to it, or null if that position\n   * is out of bounds of the board.\n   */\n  private getModulation(xBy: number, yBy: number): Position | null {\n    try {\n      return new Position(this.x + xBy, this.y + yBy);\n    } catch (e) {\n      return null;\n    }\n  }\n\n  /**\n   * Returns a new Position instance that is moved up by 1 from the position on the board that this instance describes.\n   */\n  public getUp(): Position | null {\n    return this.getModulation(0, 1);\n  }\n\n  /**\n   * Returns a new Position instance that is moved down by 1 from the position on the board that this instance describes.\n   */\n  public getDown(): Position | null {\n    return this.getModulation(0, -1);\n  }\n\n  /**\n   * Returns a new Position instance that is moved left by 1 from the position on the board that this instance describes.\n   */\n  public getLeft(): Position | null {\n    return this.getModulation(-1, 0);\n  }\n\n  /**\n   * Returns a new Position instance that is moved right by 1 from the position on the board that this instance describes.\n   */\n  public getRight(): Position | null {\n    return this.getModulation(1, 0);\n  }\n\n  /**\n   * Returns a new Position instance that is moved up by 1 and left by 1 from the position on the board that this instance describes.\n   */\n  public getUpLeft(): Position | null {\n    return this.getModulation(-1, 1);\n  }\n\n  /**\n   * Returns a new Position instance that is moved up by 1 and right by 1 from the position on the board that this instance describes.\n   */\n  public getUpRight(): Position | null {\n    return this.getModulation(1, 1);\n  }\n\n  /**\n   * Returns a new Position instance that is moved down by 1 and left by 1 from the position on the board that this instance describes.\n   */\n  public getDownLeft(): Position | null {\n    return this.getModulation(-1, -1);\n  }\n\n  /**\n   * Returns a new Position instance that is moved down by 1 and right by 1 from the position on the board that this instance describes.\n   */\n  public getDownRight(): Position | null {\n    return this.getModulation(1, -1);\n  }\n\n  /**\n   * Returns a new Position instance that is moved up by 2 from the position on the board that this instance describes.\n   */\n  public getUpUp(): Position | null {\n    return this.getModulation(0, 2);\n  }\n\n  /**\n   * Returns a new Position instance that is moved down by 2 from the position on the board that this instance describes.\n   */\n  public getDownDown(): Position | null {\n    return this.getModulation(0, -2);\n  }\n\n  /**\n   * Returns a new Position instance that is moved up by 2 and left by 1 from the position on the board that this instance describes.\n   */\n  public getUpUpLeft(): Position | null {\n    return this.getModulation(-1, 2);\n  }\n\n  /**\n   * Returns a new Position instance that is moved up by 2 and right by 1 from the position on the board that this instance describes.\n   */\n  public getUpUpRight(): Position | null {\n    return this.getModulation(1, 2);\n  }\n\n  /**\n   * Returns a new Position instance that is moved down by 2 and left by 1 from the position on the board that this instance describes.\n   */\n  public getDownDownLeft(): Position | null {\n    return this.getModulation(-1, -2);\n  }\n\n  /**\n   * Returns a new Position instance that is moved down by 2 and right by 1 from the position on the board that this instance describes.\n   */\n  public getDownDownRight(): Position | null {\n    return this.getModulation(1, -2);\n  }\n\n  /**\n   * Returns a new Position instance that is moved left by 2 and up by 1 from the position on the board that this instance describes.\n   */\n  public getLeftLeftUp(): Position | null {\n    return this.getModulation(-2, 1);\n  }\n\n  /**\n   * Returns a new Position instance that is moved left by 2 and up by 1 from the position on the board that this instance describes.\n   */\n  public getLeftLeftDown(): Position | null {\n    return this.getModulation(-2, -1);\n  }\n\n  /**\n   * Returns a new Position instance that is moved right by 2 and up by 1 from the position on the board that this instance describes.\n   */\n  public getRightRightUp(): Position | null {\n    return this.getModulation(2, 1);\n  }\n\n  /**\n   * Returns a new Position instance that is moved right by 2 and down by 1 from the position on the board that this instance describes.\n   */\n  public getRightRightDown(): Position | null {\n    return this.getModulation(2, -1);\n  }\n\n  /**\n   * Returns an array of new Position instances that are moved by 1 in all straight (horizontal and vertical) directions.\n   */\n  public getAllStraight(): Array<Position> {\n    return arrClean([\n      this.getUp(),\n      this.getDown(),\n      this.getLeft(),\n      this.getRight(),\n    ]);\n  }\n\n  /**\n   * Returns an array of new Position instances that are moved by 1 in all diagonal directions.\n   */\n  public getAllDiagonal(): Array<Position> {\n    return arrClean([\n      this.getUpLeft(),\n      this.getUpRight(),\n      this.getDownLeft(),\n      this.getDownRight(),\n    ]);\n  }\n\n  /**\n   * Returns an array of new Position instances that are moved by 1 in all straight (horizontal and vertical) and diagonal directions.\n   */\n  public getAllStraightAndDiagonal(): Array<Position> {\n    return [...this.getAllStraight(), ...this.getAllDiagonal()];\n  }\n\n  /**\n   * Returns an array of new Position instances that are moved one time equivalent of all legal knight-piece moves.\n   */\n  public getAllKnightMovePositions(): Array<Position> {\n    return arrClean([\n      this.getUpUpLeft(),\n      this.getUpUpRight(),\n      this.getDownDownLeft(),\n      this.getDownDownRight(),\n      this.getLeftLeftUp(),\n      this.getLeftLeftDown(),\n      this.getRightRightUp(),\n      this.getRightRightDown(),\n    ]);\n  }\n\n  /**\n   * Returns an array of new Position instances that are moved by a provided modulator function recursively until the\n   * modulator's returned Position instance becomes out of bounds of the board.\n   */\n  private getRecursive(modulator: () => Position | null): Array<Position> {\n    const res = [];\n    let pos: Position | null;\n    pos = this;\n    while ((pos = modulator.call(pos))) {\n      res.push(pos);\n    }\n    return res;\n  }\n\n  /**\n   * Returns an array of new Position instances that are the result of recursively moving up by 1 from the position on\n   * the board that this instance describes until the resulting Position instance becomes out of bounds of the board.\n   */\n  public getUpRecursive(): Array<Position> {\n    return this.getRecursive(this.getUp);\n  }\n\n  /**\n   * Returns an array of new Position instances that are the result of recursively moving down by 1 from the position on\n   * the board that this instance describes until the resulting Position instance becomes out of bounds of the board.\n   */\n  public getDownRecursive(): Array<Position> {\n    return this.getRecursive(this.getDown);\n  }\n\n  /**\n   * Returns an array of new Position instances that are the result of recursively moving left by 1 from the position on\n   * the board that this instance describes until the resulting Position instance becomes out of bounds of the board.\n   */\n  public getLeftRecursive(): Array<Position> {\n    return this.getRecursive(this.getLeft);\n  }\n\n  /**\n   * Returns an array of new Position instances that are the result of recursively moving right by 1 from the position on\n   * the board that this instance describes until the resulting Position instance becomes out of bounds of the board.\n   */\n  public getRightRecursive(): Array<Position> {\n    return this.getRecursive(this.getRight);\n  }\n\n  /**\n   * Returns an array of new Position instances that are the result of recursively moving up by 1 and left by 1 from the\n   * position on the board that this instance describes until the resulting Position instance becomes out of bounds of\n   * the board.\n   */\n  public getUpLeftRecursive(): Array<Position> {\n    return this.getRecursive(this.getUpLeft);\n  }\n\n  /**\n   * Returns an array of new Position instances that are the result of recursively moving up by 1 and right by 1 from the\n   * position on the board that this instance describes until the resulting Position instance becomes out of bounds of\n   * the board.\n   */\n  public getUpRightRecursive(): Array<Position> {\n    return this.getRecursive(this.getUpRight);\n  }\n\n  /**\n   * Returns an array of new Position instances that are the result of recursively moving down by 1 and left by 1 from the\n   * position on the board that this instance describes until the resulting Position instance becomes out of bounds of\n   * the board.\n   */\n  public getDownLeftRecursive(): Array<Position> {\n    return this.getRecursive(this.getDownLeft);\n  }\n\n  /**\n   * Returns an array of new Position instances that are the result of recursively moving down by 1 and right by 1 from the\n   * position on the board that this instance describes until the resulting Position instance becomes out of bounds of\n   * the board.\n   */\n  public getDownRightRecursive(): Array<Position> {\n    return this.getRecursive(this.getDownRight);\n  }\n\n  /**\n   * Returns an array of new Position instances that are the result of recursively moving by 1 in all straight\n   * (horizontal and vertical) directions from the position on the board that this instance describes until the\n   * resulting Position instance becomes out of bounds of the board.\n   */\n  public getAllStraightRecursive(): Array<Array<Position>> {\n    return [\n      this.getUpRecursive(),\n      this.getDownRecursive(),\n      this.getLeftRecursive(),\n      this.getRightRecursive(),\n    ];\n  }\n\n  /**\n   * Returns an array of new Position instances that are the result of recursively moving by 1 in all diagonal\n   * directions from the position on the board that this instance describes until the resulting Position instance\n   * becomes out of bounds of the board.\n   */\n  public getAllDiagonalRecursive(): Array<Array<Position>> {\n    return [\n      this.getUpLeftRecursive(),\n      this.getUpRightRecursive(),\n      this.getDownLeftRecursive(),\n      this.getDownRightRecursive(),\n    ];\n  }\n\n  /**\n   * Returns an array of new Position instances that are the result of recursively moving by 1 in all straight\n   * (horizontal and vertical) and diagonal directions from the position on the board that this instance describes until\n   * the resulting Position instance becomes out of bounds of the board.\n   */\n  public getAllStraightAndDiagonalRecursive(): Array<Array<Position>> {\n    return [\n      ...this.getAllStraightRecursive(),\n      ...this.getAllDiagonalRecursive(),\n    ];\n  }\n}\n","import { createAssertFunction } from './util';\nimport { Position } from './Position';\n\nconst A_CHAR_CODE = 'A'.charCodeAt(0);\n\n/**\n * Converts the first value of an XY-coordinate to A1-notation.\n */\nexport function from_X_to_A(x: number): string {\n  return String.fromCharCode(x + A_CHAR_CODE);\n}\n\n/**\n * Converts the second value of an XY-coordinate to A1-notation.\n */\nexport function from_Y_to_1(y: number): string {\n  return (y + 1).toString();\n}\n\n/**\n * Converts the first character of A1-notation to the first value of an XY-coordinate.\n */\nexport function from_A_to_X(a: string): number {\n  return a.toUpperCase().charCodeAt(0) - A_CHAR_CODE;\n}\n\n/**\n * Converts the second character of A1-notation to the second value of an XY-coordinate.\n */\nexport function from_1_to_Y(n: string): number {\n  return Number(n.charAt(0)) - 1;\n}\n\n/**\n * Converts a XY-coordinate-array to an A1-notation string.\n */\nexport function from_XY_to_A1(pos: Array<number>): string {\n  return from_X_to_A(pos[0]) + from_Y_to_1(pos[1]);\n}\n\n/**\n * Converts an A1-notation string to a XY-coordinate-array.\n */\nexport function from_A1_to_XY(a1: string): Array<number> {\n  return [from_A_to_X(a1.charAt(0)), from_1_to_Y(a1.charAt(1))];\n}\n\n/**\n * Converts an A1-notation string to a Position instance.\n */\nexport function from_A1_to_Position(a1: string): Position {\n  return new Position(from_A_to_X(a1.charAt(0)), from_1_to_Y(a1.charAt(1)));\n}\n\n/**\n * Converts an A1-notation string to a Position instance.\n */\nexport function from_XY_to_Position(xy: Array<number>): Position {\n  return new Position(xy[0], xy[1]);\n}\n\n/**\n * Returns whether the argument is a positive integer where 0 <= arg <= 7.\n */\nexport function isValidXYPoint(n: number): boolean {\n  return n >= 0 && n <= 7;\n}\n\n/**\n * Returns whether both points in an XY-coordinate is a positive integer where 0 <= arg <= 7.\n */\nexport function isValidXY(pos: Array<number>): boolean {\n  return isValidXYPoint(pos[0]) && isValidXYPoint(pos[1]);\n}\n\n/**\n * Returns whether a string is valid A1-notation.\n */\nexport function isValidA1(a1: string): boolean {\n  return a1.length === 2 && isValidXY(from_A1_to_XY(a1));\n}\n\n/**\n * Throws a TypeError if the argument is not a valid XY-coordinate point.\n * @see isValidXYPoint\n *\n * @function assertValidXYPoint\n * @throws {TypeError}\n */\nexport const assertValidXYPoint = createAssertFunction(\n  'a positive integer between 0 and 7',\n  isValidXYPoint,\n);\n\n/**\n * Throws a TypeError if the argument is not a valid XY-coordinate.\n * @see isValidXY\n *\n * @function assertValidXY\n * @throws {TypeError}\n */\nexport const assertValidXY = createAssertFunction(\n  'an array containing two positive integers between 0 and 7',\n  isValidXY,\n);\n\n/**\n * Throws a TypeError if the argument is not valid A1-notation.\n * @see isValidA1\n *\n * @function assertValidA1\n * @throws {TypeError}\n */\nexport const assertValidA1 = createAssertFunction(\n  'a valid A1-notation string',\n  isValidA1,\n);\n","import { from_A1_to_XY } from './coordinates';\nimport type { Position } from './Position';\nimport type { Game } from './Game';\nimport type { Move } from './Move';\nimport type { Piece } from './AbstractPiece';\n\nexport class Board {\n  public game: Game;\n  public grid: Array<Array<Piece | null>>;\n\n  public constructor(game: Game) {\n    this.game = game;\n    this.grid = [];\n    let i = 0;\n    while (i < 8) {\n      this.grid.push(new Array(8).fill(null, 0, 7));\n      i++;\n    }\n  }\n\n  /**\n   * Returns the piece at the given XY-coordinates or null if no piece is found there.\n   */\n  public getPieceByXY(x: number, y: number): Piece | null {\n    return this.grid[y][x];\n  }\n\n  /**\n   * Returns the piece at the given Position or null if no piece is found there.\n   */\n  public getPieceByPosition(position: Position): Piece | null {\n    return this.getPieceByXY(position.x, position.y);\n  }\n\n  /**\n   * Returns the piece at the given A1-notation-coordinates or null if no piece is found there.\n   */\n  public getPieceByA1(a1: string): Piece | null {\n    const [x, y] = from_A1_to_XY(a1);\n    return this.getPieceByXY(x, y);\n  }\n\n  /**\n   * Sets a piece to the board.\n   */\n  public setPiece(piece: Piece): void {\n    const pos = piece.position;\n    if (pos) this.grid[pos.y][pos.x] = piece;\n  }\n\n  /**\n   * Removes a piece from the board.\n   * This method does not check legality or whether this action is part of a move in the game.\n   */\n  public removePiece(piece: Piece | null): void {\n    if (piece) {\n      const pos = piece.position;\n      if (pos) this.grid[pos.y][pos.x] = null;\n    }\n  }\n\n  /**\n   * Updates the board instance based on the information contained within a provided Move instance.\n   */\n  public registerMove(move: Move): void {\n    const from = move.from;\n    const to = move.to;\n    const piece = this.grid[from.y][from.x];\n    this.grid[to.y][to.x] = piece;\n    this.grid[from.y][from.x] = null;\n  }\n\n  /**\n   * Updates the board instance based on the information contained within a provided Move instance that is known to make\n   * out a swap (used for castling moves).\n   */\n  public registerSwap(move: Move): void {\n    const from = move.from;\n    const to = move.to;\n    const pieceFrom = this.grid[from.y][from.x];\n    const pieceTo = this.grid[to.y][to.x];\n    this.grid[to.y][to.x] = pieceFrom;\n    this.grid[from.y][from.x] = pieceTo;\n  }\n}\n","import { Piece } from './AbstractPiece';\nimport type { Position } from './Position';\n\nexport class King extends Piece {\n  /**\n   * Returns a Position array with all piece-specific move positions within bounds of the board.\n   */\n  protected getMovePositionsWithinBounds(): Array<Position | Array<Position>> {\n    const pos = this.position;\n    if (!pos) return [];\n    return pos.getAllStraightAndDiagonal();\n  }\n\n  /**\n   * Returns whether a move to a target position is a castling move.\n   */\n  public isCastleMove(target: Position): boolean {\n    const targetPiece = this.game.board.getPieceByPosition(target);\n    if (!targetPiece) return false;\n    // it is not necessary to check whether the taget piece is an own piece since an enemy piece will never be in the\n    // designated position without having moved, which gets checked.\n    return (\n      targetPiece.type === 'Rook' && !targetPiece.hasMoved && !this.hasMoved\n    );\n  }\n}\n","import { Piece } from './AbstractPiece';\nimport type { Position } from './Position';\n\nexport class Knight extends Piece {\n  /**\n   * Returns a Position array with all piece-specific move positions within bounds of the board.\n   */\n  protected getMovePositionsWithinBounds(): Array<Position | Array<Position>> {\n    const pos = this.position;\n    return pos ? pos.getAllKnightMovePositions() : [];\n  }\n}\n","import type { Piece } from './AbstractPiece';\nimport type { Position } from './Position';\n\nexport class Move {\n  public piece: Piece;\n  public takes: Piece | null;\n  public from: Position;\n  public to: Position;\n\n  public constructor(piece: Piece, to: Position, takes: Piece | null = null) {\n    const pos = piece.position;\n    if (!pos) {\n      throw new Error('Cannot move a piece that is not on the board.');\n    }\n\n    this.piece = piece;\n    this.takes = takes;\n    this.from = pos.clone();\n    this.to = to.clone();\n  }\n\n  public toJSON(): Array<Array<number>> {\n    return [\n      [this.from.x, this.from.y],\n      [this.to.x, this.to.y],\n    ];\n  }\n}\n","import { Piece } from './AbstractPiece';\nimport type { Position } from './Position';\n\nexport class Pawn extends Piece {\n  /**\n   * Returns a Position array with all piece-specific move positions within bounds of the board.\n   */\n  protected getMovePositionsWithinBounds(): Array<Position | Array<Position>> {\n    const board = this.game.board;\n    const pos = this.position;\n    const res = [];\n\n    if (!pos) {\n      return [];\n    }\n\n    if (this.color === 'white') {\n      const upPos = pos.getUp();\n      if (upPos) {\n        res.push(upPos);\n      }\n\n      const upUpPos = pos.getUpUp();\n      if (upUpPos && !this.hasMoved) {\n        res.push(upUpPos);\n      }\n\n      const upLeftPos = pos.getUpLeft();\n      if (upLeftPos) {\n        const diagLeftPiece = board.getPieceByPosition(upLeftPos);\n        if (diagLeftPiece) {\n          const diagLeftPos = diagLeftPiece.position;\n          if (diagLeftPos && diagLeftPiece.color === 'black') {\n            res.push(diagLeftPos.clone());\n          }\n        }\n      }\n\n      const upRightPos = pos.getUpRight();\n      if (upRightPos) {\n        const diagRightPiece = board.getPieceByPosition(upRightPos);\n        if (diagRightPiece) {\n          const diagLeftPos = diagRightPiece.position;\n          if (diagLeftPos && diagRightPiece.color === 'black') {\n            res.push(diagLeftPos.clone());\n          }\n        }\n      }\n    } else {\n      const downPos = pos.getDown();\n      if (downPos) {\n        res.push(downPos);\n      }\n\n      const downDownPos = pos.getDownDown();\n      if (downDownPos && !this.hasMoved) {\n        res.push(downDownPos);\n      }\n\n      const downLeftPos = pos.getDownLeft();\n      if (downLeftPos) {\n        const diagLeftPiece = board.getPieceByPosition(downLeftPos);\n        if (diagLeftPiece) {\n          const diagLeftPos = diagLeftPiece.position;\n          if (diagLeftPos && diagLeftPiece.color === 'white') {\n            res.push(diagLeftPos.clone());\n          }\n        }\n      }\n\n      const downRightPos = pos.getDownRight();\n      if (downRightPos) {\n        const diagRightPiece = board.getPieceByPosition(downRightPos);\n        if (diagRightPiece) {\n          const diagLeftPos = diagRightPiece.position;\n          if (diagLeftPos && diagRightPiece.color === 'white') {\n            res.push(diagLeftPos.clone());\n          }\n        }\n      }\n    }\n    return res;\n  }\n}\n","import { Piece } from './AbstractPiece';\nimport type { Position } from './Position';\n\nexport class Queen extends Piece {\n  /**\n   * Returns a Position array with all piece-specific move positions within bounds of the board.\n   */\n  protected getMovePositionsWithinBounds(): Array<Position | Array<Position>> {\n    const pos = this.position;\n    return pos ? pos.getAllStraightAndDiagonalRecursive() : [];\n  }\n}\n","import { Piece } from './AbstractPiece';\nimport type { Position } from './Position';\n\nexport class Rook extends Piece {\n  /**\n   * Returns a Position array with all piece-specific move positions within bounds of the board.\n   */\n  protected getMovePositionsWithinBounds(): Array<Position | Array<Position>> {\n    const pos = this.position;\n    if (!pos) return [];\n    return pos.getAllStraightRecursive();\n  }\n\n  /**\n   * Returns whether a move to a target position is a castling move.\n   */\n  public isCastleMove(target: Position): boolean {\n    const targetPiece = this.game.board.getPieceByPosition(target);\n    if (!targetPiece) return false;\n    // it is not necessary to check whether the taget piece is an own piece since an enemy piece will never be in the\n    // designated position without having moved, which gets checked.\n    return (\n      targetPiece.type === 'King' && !targetPiece.hasMoved && !this.hasMoved\n    );\n  }\n}\n","import { Position } from './Position';\nimport { Pawn } from './Pawn';\nimport { Knight } from './Knight';\nimport { Bishop } from './Bishop';\nimport { Queen } from './Queen';\nimport { Rook } from './Rook';\nimport { King } from './King';\nimport type { Piece } from './AbstractPiece';\nimport type { Game } from './Game';\nimport type { Move } from './Move';\n\nexport class Player {\n  public game: Game;\n  public color: string;\n  public pieces: Piece[];\n\n  public constructor(game: Game, color: string) {\n    this.game = game;\n    this.color = color;\n\n    let row1: string, row2: string;\n    if (color === 'white') {\n      row1 = '1';\n      row2 = '2';\n    } else if (color === 'black') {\n      row1 = '8';\n      row2 = '7';\n    } else {\n      throw new Error('Invalid color');\n    }\n\n    this.pieces = [\n      new King(this, 0, Position.fromA1('E' + row1)),\n      new Queen(this, 1, Position.fromA1('D' + row1)),\n      new Bishop(this, 2, Position.fromA1('C' + row1)),\n      new Bishop(this, 3, Position.fromA1('F' + row1)),\n      new Knight(this, 4, Position.fromA1('B' + row1)),\n      new Knight(this, 5, Position.fromA1('G' + row1)),\n      new Rook(this, 6, Position.fromA1('A' + row1)),\n      new Rook(this, 7, Position.fromA1('H' + row1)),\n      new Pawn(this, 8, Position.fromA1('A' + row2)),\n      new Pawn(this, 9, Position.fromA1('B' + row2)),\n      new Pawn(this, 10, Position.fromA1('C' + row2)),\n      new Pawn(this, 11, Position.fromA1('D' + row2)),\n      new Pawn(this, 12, Position.fromA1('E' + row2)),\n      new Pawn(this, 13, Position.fromA1('F' + row2)),\n      new Pawn(this, 14, Position.fromA1('G' + row2)),\n      new Pawn(this, 15, Position.fromA1('H' + row2)),\n    ];\n  }\n\n  /**\n   * Returns an array of Move instances that describe moves of this Piece.\n   */\n  public get moves(): Move[] {\n    return this.game.moves.filter((move) => {\n      return move.piece.player === this;\n    });\n  }\n}\n","import { Board } from './Board';\nimport { Player } from './Player';\nimport { Move } from './Move';\nimport { isEven } from './util';\nimport { Position } from './Position';\nimport { Piece } from './AbstractPiece';\nimport { from_A1_to_Position, from_XY_to_Position } from './coordinates';\n\nexport class Game {\n  /**\n   * Recreates a Game instance from a previously stringified Game instance.\n   * @throws {Error} on invalid JSON data\n   */\n  public static fromJSON(data: string): Game {\n    try {\n      const game = new Game();\n      const moves = JSON.parse(data);\n      for (let i = 0; i < moves.length; i++) {\n        game.makeMove(moves[i][0], moves[i][1]);\n      }\n      return game;\n    } catch (e) {\n      throw new Error('Invalid JSON data');\n    }\n  }\n\n  /**\n   * The game board\n   */\n  public board: Board;\n\n  /**\n   * White player\n   */\n  public white: Player;\n\n  /**\n   * Black player\n   */\n  public black: Player;\n\n  /**\n   * An array containing all moves made in the game\n   */\n  public moves: Array<Move>;\n\n  /**\n   * Returns an instance of Game\n   */\n  public constructor() {\n    this.board = new Board(this);\n    this.white = new Player(this, 'white');\n    this.black = new Player(this, 'black');\n    this.moves = [];\n  }\n\n  /**\n   * Returns whether it is white player's turn to move.\n   */\n  public get isWhitesTurnToMove(): boolean {\n    return isEven(this.moves.length);\n  }\n\n  /**\n   * Returns whether it is black player's turn to move.\n   */\n  public get isBlacksTurnToMove(): boolean {\n    return !isEven(this.moves.length);\n  }\n\n  /**\n   * Returns whether it is black player's turn to move.\n   */\n  public get activePlayer(): Player {\n    return this.isWhitesTurnToMove ? this.white : this.black;\n  }\n\n  /**\n   * Iterate each piece on the board.\n   *\n   * @param f - a callback function to invoke for each Piece. If it returns true, iteration ends.\n   * @returns true if iteration was ended before completion.\n   */\n  public forEachPiece(f: (piece?: Piece) => boolean | void): boolean | void {\n    const w = this.white.pieces;\n    const b = this.black.pieces;\n    for (let i = 0; i < 16; i++) {\n      if (f(w[i]) || f(b[i])) {\n        return true;\n      }\n    }\n  }\n\n  /**\n   * Iterate each white piece on the board.\n   *\n   * @param f - a callback function to invoke for each Piece. If it returns true, iteration ends.\n   * @returns true if iteration was ended before completion.\n   */\n  public forEachWhitePiece(\n    f: (piece?: Piece) => boolean | void,\n  ): boolean | void {\n    const w = this.white.pieces;\n    for (let i = 0; i < 16; i++) {\n      if (f(w[i])) {\n        return true;\n      }\n    }\n  }\n\n  /**\n   * Iterate each black piece on the board.\n   *\n   * @param f - a callback function to invoke for each Piece. If it returns true, iteration ends.\n   * @returns true if iteration was ended before completion.\n   */\n  public forEachBlackPiece(\n    f: (piece?: Piece) => boolean | void,\n  ): boolean | void {\n    const b = this.black.pieces;\n    for (let i = 0; i < 16; i++) {\n      if (f(b[i])) {\n        return true;\n      }\n    }\n  }\n\n  /**\n   * Iterate each piece on the board belonging to the player whose turn it is to move.\n   *\n   * @param f - a callback function to invoke for each Piece. If it returns true, iteration ends.\n   * @returns true if iteration was ended before completion.\n   */\n  public forEachActivePlayerPiece(\n    f: (piece?: Piece) => boolean | void,\n  ): boolean | void {\n    return this.isWhitesTurnToMove\n      ? this.forEachWhitePiece(f)\n      : this.forEachBlackPiece(f);\n  }\n\n  /**\n   * Ensures the argument is converted into a Position instance.\n   */\n  private ensurePosition(from: Position | string | Array<number>): Position {\n    return from instanceof Position\n      ? from\n      : typeof from === 'string'\n      ? from_A1_to_Position(from)\n      : from_XY_to_Position(from);\n  }\n\n  /**\n   * Get a Piece instance from the board by either Position, an A1 string or XY-coordinates\n   */\n  private getPiece(\n    from?: Position | string | Array<number> | Piece,\n  ): Piece | null {\n    return !from\n      ? null\n      : from instanceof Piece\n      ? from\n      : this.board.getPieceByPosition(this.ensurePosition(from));\n  }\n\n  /**\n   * Iterate each valid move position for either all active player pieces or a given piece.\n   *\n   * @param f - a callback function to invoke for each Piece. If it returns true, iteration ends.\n   * @param pieceOrCoordinate - only iterate a single piece's valid move positions. Can be the Piece to move, or where\n   * to find the piece which can be a Position instance, XY-array or A1-notation string.\n   * @returns true if iteration was ended before completion.\n   */\n  public forEachValidMove(\n    f: (position?: Position, piece?: Piece) => boolean | void,\n    pieceOrCoordinate?: Piece | Position | string | Array<number>,\n  ): boolean | void {\n    const piece = this.getPiece(pieceOrCoordinate);\n    return piece\n      ? piece.forEachValidMovePosition((pos) => {\n          return f(pos, piece);\n        })\n      : this.forEachActivePlayerPiece((piece) => {\n          if (piece) {\n            return piece.forEachValidMovePosition((pos) => {\n              return f(pos, piece);\n            });\n          } else return;\n        });\n  }\n\n  /**\n   * Moves a piece on the board.\n   * If the target position already has a piece belonging to the opposing player, it is removed from the board.\n   *\n   * @param pieceOrCoordinate - The Piece to move, or where to find the piece which can be a Position instance, XY-array\n   * or A1-notation string.\n   * @param to - The Position to move to.\n   * @param skipValidation - skips validation of the move's legality according to the rules of the game. This is used\n   * internally for performance reasons when cloning a game, which repeats the moves that were previously validated.\n   *\n   * @throws {Error} on invalid move, unless `skipValidation` is true.\n   */\n  public makeMove(\n    pieceOrCoordinate: Piece | Position,\n    to: Position | string | Array<number>,\n    skipValidation?: boolean,\n  ): void {\n    to = this.ensurePosition(to);\n    const piece = this.getPiece(pieceOrCoordinate);\n    if (piece && (skipValidation || piece.isValidMove(to))) {\n      const targetPiece = piece.game.board.getPieceByPosition(to);\n      let move: Move;\n      if (piece.isCastleMove(to)) {\n        move = new Move(piece, to);\n        this.board.registerSwap(move);\n        if (targetPiece) {\n          targetPiece.registerMove(new Move(targetPiece, move.from));\n        }\n      } else {\n        move = new Move(piece, to, targetPiece);\n        this.board.registerMove(move);\n        if (targetPiece) {\n          targetPiece.remove();\n        }\n      }\n      piece.registerMove(move);\n      this.moves.push(move);\n    } else {\n      throw new Error('Invalid move.');\n    }\n  }\n\n  /**\n   * Returns a deep clone of the game instance.\n   */\n  public clone(): Game {\n    const game = new Game();\n    const w = game.white.pieces;\n    const b = game.black.pieces;\n    const moves = this.moves;\n    for (let i = 0; i < moves.length; i++) {\n      const piece = moves[i].piece;\n      game.makeMove(\n        (piece.color === 'white' ? w : b)[piece.index],\n        moves[i].to.clone(),\n        true,\n      );\n    }\n    return game;\n  }\n\n  /**\n   * Stringifies the necessary data for reconstructing the game.\n   */\n  public toJSON(): string {\n    return JSON.stringify(this.moves);\n  }\n}\n"],"names":["player","index","position","this","moveCount","game","board","setPiece","Object","Piece","constructor","name","color","moves","filter","move","piece","_this","to","clone","target","targetPiece","getPieceByPosition","activePlayer","f","isOwnTurn","positions","getMovePositionsWithinBounds","i","length","item","Array","isArray","j","isMoveTargetOwnPiece","_target","isCastleMove","res","forEachValidMovePosition","compare","__extends","Bishop","pos","getAllDiagonalRecursive","arrClean","arr","l","push","createAssertFunction","expectedToBe","validate","arg","TypeError","defineProperty","value","replace","isEven","n","x","y","skipValidation","assertValidXY","Position","a1","xy","from_A1_to_XY","from_XY_to_A1","xBy","yBy","e","getModulation","getUp","getDown","getLeft","getRight","getUpLeft","getUpRight","getDownLeft","getDownRight","getAllStraight","getAllDiagonal","getUpUpLeft","getUpUpRight","getDownDownLeft","getDownDownRight","getLeftLeftUp","getLeftLeftDown","getRightRightUp","getRightRightDown","modulator","call","getRecursive","getUpRecursive","getDownRecursive","getLeftRecursive","getRightRecursive","getUpLeftRecursive","getUpRightRecursive","getDownLeftRecursive","getDownRightRecursive","getAllStraightRecursive","A_CHAR_CODE","charCodeAt","from_X_to_A","String","fromCharCode","from_Y_to_1","toString","from_A_to_X","a","toUpperCase","from_1_to_Y","Number","charAt","isValidXYPoint","isValidXY","isValidA1","assertValidXYPoint","assertValidA1","grid","fill","Board","getPieceByXY","_a","from","pieceFrom","pieceTo","King","getAllStraightAndDiagonal","type","hasMoved","Knight","getAllKnightMovePositions","takes","Error","Move","Pawn","upPos","upUpPos","getUpUp","upLeftPos","diagLeftPiece","diagLeftPos","upRightPos","diagRightPiece","downPos","downDownPos","getDownDown","downLeftPos","downRightPos","Queen","getAllStraightAndDiagonalRecursive","Rook","row1","row2","pieces","fromA1","Player","white","black","Game","data","JSON","parse","makeMove","isWhitesTurnToMove","w","b","forEachWhitePiece","forEachBlackPiece","from_A1_to_Position","from_XY_to_Position","ensurePosition","pieceOrCoordinate","getPiece","forEachActivePlayerPiece","isValidMove","registerSwap","registerMove","remove","stringify"],"mappings":"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"}